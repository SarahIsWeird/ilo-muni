---
import Layout from "@layouts/Layout.astro";
import EpochRangePicker from "@components/EpochRangePicker.astro";
import Loader from "@components/Loader.astro";
import LenDropdown from "@components/LenDropdown.astro";
import { EARLIEST_YEAR, LATEST_YEAR } from "@utils/constants";

const frontmatter = { title: "ilo Muni" };
---

<script>
  import type {
    Length,
    SearchURLParams,
    MinSentLen,
    Scale,
    Smoothing,
  } from "@utils/input";
  import { inputToQueries } from "@utils/input";
  import { reloadUsageChart } from "@utils/chart";
  import { fetchManyOccurrenceSet } from "@utils/sqlite";
  import { EARLIEST_TIMESTAMP, LATEST_TIMESTAMP } from "@utils/constants";

  const SAMPLE_SEARCHES = [
    // duh
    "toki, pona, toki pona",
    // phrase trends
    "tomo tawa, ilo tawa",
    "sina seme, sina pilin seme, sina pali e seme",
    // isolating phrases
    "toki_1 - toki_2, pona_1 - pona_2",
    // synonyms
    "lukin, oko, lukin + oko",
    "ale, ali, ale + ali",
    "ala, x, ala + x",
    "anu, y, anu + y",
    // word groups
    "laso, loje, walo, jelo, pimeja",
    "soweli, waso, kala, akesi, pipi",
    "sewi, poka, anpa, sinpin, monsi",
    "meli, mije, tonsi",
    "pu, ku, su",
    "sin, lukin, kin, namako, oko",
    "selo, sijelo",
    // modifier usage
    "wawa a, wawa mute, wawa suli, wawa sewi",
    "tenpo ni, tenpo pini, tenpo kama, tenpo mute, tenpo suli, tenpo poka",
    // grammatical things
    "kepeken ilo, kepeken e ilo",
    "kin la, poka la, sama la, namako la",
    "ale la, ala la",
    "pali e, lon e, mama e, kama e",
    // names
    "kekan, kekan san, jan kekan, mun kekan",
    "sonja, jan sonja",
    // disambiguation
    "san - kekan san",
    "toki - toki pona",
  ];

  const SCALE_OPTS = ["absolute", "relative"];

  function randomElem(arr: any[]) {
    return arr[Math.floor(Math.random() * arr.length)];
  }

  function isValidTimestamp(timestamp: number): boolean {
    if (!timestamp) {
      return false;
    }
    if (timestamp < EARLIEST_TIMESTAMP) {
      return false;
    }
    if (timestamp > LATEST_TIMESTAMP) {
      return false;
    }
    return true;
  }

  function getInitialParams(): SearchURLParams {
    const urlParams = new URLSearchParams(window.location.search);

    const queryParam = urlParams.get("query");
    let query: string;
    if (queryParam) {
      query = queryParam;
    } else {
      query = randomElem(SAMPLE_SEARCHES);
    }

    const minLenParam = urlParams.get("minSentLen") || "";
    const minLenParsed = parseInt(minLenParam, 10);
    let minSentLen: MinSentLen;
    if (minLenParsed && 1 <= minLenParsed && minLenParsed <= 6) {
      minSentLen = minLenParam as MinSentLen;
    } else {
      minSentLen = "1";
    }

    const scaleParam = urlParams.get("scale");
    let scale: Scale;
    if (scaleParam && SCALE_OPTS.includes(scaleParam)) {
      scale = scaleParam as Scale;
    } else {
      scale = "relative";
    }

    const smoothingParam = urlParams.get("smoothing") || "";
    const smoothingParsed = parseInt(smoothingParam, 10);
    let smoothing: Smoothing;
    if (smoothingParam && smoothingParsed >= 0) {
      smoothing = smoothingParam as Smoothing;
    } else {
      smoothing = "2";
    }

    const startParam = urlParams.get("start") || "";
    const startParsed = parseInt(startParam, 10);
    let start: string;
    if (isValidTimestamp(startParsed)) {
      start = startParam;
    } else {
      start = EARLIEST_TIMESTAMP.toString();
    }

    const endParam = urlParams.get("end") || "";
    const endParsed = parseInt(endParam, 10);
    let end: string;
    if (isValidTimestamp(endParsed)) {
      end = endParam;
    } else {
      end = LATEST_TIMESTAMP.toString();
    }

    return { query, minSentLen, scale, smoothing, start, end };
  }

  function toUrlParams(params: SearchURLParams) {
    const urlParams = new URLSearchParams();

    for (const key in params) {
      // @ts-ignore
      if (params[key]) {
        //@ts-ignore
        urlParams.append(key, params[key]);
      }
    }

    const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
    window.history.replaceState({}, "", newUrl);
  }

  async function updatePage(
    canvas: HTMLCanvasElement,
    searchBox: HTMLInputElement,
    sentLenDropdown: HTMLInputElement,
    scaleDropdown: HTMLInputElement,
    smoothingDropdown: HTMLInputElement,
    startDropdown: HTMLInputElement,
    endDropdown: HTMLInputElement,
    searchLoader: HTMLSpanElement,
  ) {
    const queryText = searchBox.value;
    const sentLen = Number(sentLenDropdown.value) as Length;
    const relative = scaleDropdown.value === "relative";
    const smoothing = Number(smoothingDropdown.value);
    const start = Number(startDropdown.value);
    const end = Number(endDropdown.value);

    // disable smoothness if relative if set
    // graphing absolute data with smoothness is silly
    if (relative) {
      smoothingDropdown.disabled = false;
    } else {
      smoothingDropdown.disabled = true;
    }

    searchLoader.style.visibility = "visible";
    let queries = await updateChart(
      canvas,
      queryText,
      sentLen,
      relative,
      smoothing,
      start,
      end,
    );
    searchLoader.style.visibility = "hidden";
    if (!queries) {
      return;
    }

    // rewrite urlParams with query repr so we don't copy user input error
    let queryReprs = queries.map((query) => query.repr);
    let query = queryReprs.join(", ");

    let urlParams: SearchURLParams = {
      query: query,
      minSentLen: sentLenDropdown.value as MinSentLen,
      scale: scaleDropdown.value as Scale,
      smoothing: smoothingDropdown.value as Smoothing,
      start: startDropdown.value,
      end: endDropdown.value,
    };

    toUrlParams(urlParams);
  }

  async function updateChart(
    canvas: HTMLCanvasElement,
    input: string,
    min_sent_len: Length,
    relative: boolean,
    smoothing: number,
    start: number,
    end: number,
  ) {
    const queries = inputToQueries(input, min_sent_len);
    if (queries.length === 0) {
      return;
    }

    const results = await fetchManyOccurrenceSet(
      queries,
      relative,
      smoothing,
      start,
      end,
    );
    if (results.length === 0) {
      // TODO: tell user nothing came back
      return;
    }
    if (results.length < queries.length) {
      // TODO: tell user some (which) words were not found
    }

    await reloadUsageChart(canvas, results);
    return queries;
  }

  document.addEventListener("DOMContentLoaded", async () => {
    const searchBox = document.getElementById("searchBox")! as HTMLInputElement;
    const sentLenDropdown = document.getElementById(
      "sentLenDropdown",
    )! as HTMLInputElement;
    const scaleDropdown = document.getElementById(
      "scaleDropdown",
    )! as HTMLInputElement;
    const smoothingDropdown = document.getElementById(
      "smoothingDropdown",
    )! as HTMLInputElement;
    const startDropdown = document.getElementById(
      "startDropdown",
    )! as HTMLInputElement;
    const endDropdown = document.getElementById(
      "endDropdown",
    )! as HTMLInputElement;

    const searchLoader = document.getElementById(
      "searchLoader",
    )! as HTMLSpanElement;

    let initialParams = getInitialParams();
    searchBox.value = initialParams.query;
    sentLenDropdown.value = initialParams.minSentLen;
    scaleDropdown.value = initialParams.scale;
    smoothingDropdown.value = initialParams.smoothing;
    startDropdown.value = initialParams.start;
    endDropdown.value = initialParams.end;

    const usageCanvas = document.getElementById("usage")! as HTMLCanvasElement;
    await updatePage(
      usageCanvas,
      searchBox,
      sentLenDropdown,
      scaleDropdown,
      smoothingDropdown,
      startDropdown,
      endDropdown,
      searchLoader,
    );

    const form = document.getElementById("usageForm")! as HTMLFormElement;
    form.addEventListener("change", async () => {
      await updatePage(
        usageCanvas,
        searchBox,
        sentLenDropdown,
        scaleDropdown,
        smoothingDropdown,
        startDropdown,
        endDropdown,
        searchLoader,
      );
    });
  });
</script>

<Layout frontmatter={frontmatter}>
  <div>
    <form id="usageForm" onsubmit="return false;" autocomplete="off">
      <div>
        <label for="searchBox"></label>
        <input
          type="text"
          id="searchBox"
          spellcheck="false"
          style="width: 65%; height: 1.6em; font-size: 18px; margin-right: 0.4em;"
        />
        <Loader id="searchLoader" />
      </div>

      <div>
        <LenDropdown
          maxLength={6}
          singularText="All sentences"
          pluralText="+ words per sentence"
          id="sentLenDropdown"
        />

        <select id="scaleDropdown">
          <option value="absolute">Absolute</option>
          <option value="relative" selected={true}>Relative</option>
        </select>

        <select id="smoothingDropdown">
          {
            Array.from({ length: 10 }, (_, i) => (
              <option value={i} selected={i === 2}>
                {i} smoothing
              </option>
            ))
          }
          {
            Array.from({ length: 5 }, (_, i) => (
              <option value={(i + 1) * 10}>{(i + 1) * 10} smoothing</option>
            ))
          }
        </select>
        <EpochRangePicker
          startYear={EARLIEST_YEAR}
          endYear={LATEST_YEAR}
          startId="startDropdown"
          endId="endDropdown"
          renderAs="date"
        />
      </div>
    </form>
  </div>

  <div style="position: relative">
    <canvas id="usage" style="width: 100%; margin-top: 0.25em"></canvas>
    <div id="usageLegend" style="height: 6em; margin-top: 0.75em;"></div>
  </div>

  <div id="errorBin"></div>
</Layout>
